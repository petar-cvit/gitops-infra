apiVersion: cyclops-ui.com/v1alpha1
kind: Module
metadata:
  name: message-queue
  namespace: cyclops
spec:
  template:
    path: bitnami/rabbitmq
    repo: https://github.com/bitnami/charts
    version: main
  values:
    advancedConfiguration: ""
    advancedConfigurationExistingSecret: ""
    affinity: {}
    args: []
    auth:
      enableLoopbackUser: false
      erlangCookie: ""
      existingErlangSecret: ""
      existingPasswordSecret: ""
      existingSecretErlangKey: ""
      existingSecretPasswordKey: ""
      password: ""
      securePassword: true
      tls:
        autoGenerated: false
        caCertificate: ""
        enabled: false
        existingSecret: ""
        existingSecretFullChain: false
        failIfNoPeerCert: true
        overrideCaCertificate: ""
        serverCertificate: ""
        serverKey: ""
        sslOptionsPassword:
          enabled: false
          existingSecret: ""
          key: ""
          password: ""
        sslOptionsVerify: verify_peer
      username: user
    automountServiceAccountToken: true
    clusterDomain: cluster.local
    clustering:
      addressType: hostname
      enabled: true
      forceBoot: false
      name: ""
      partitionHandling: autoheal
      rebalance: false
    command: []
    common: null
    commonAnnotations: {}
    commonLabels: {}
    communityPlugins: ""
    configuration: >-
      ## Username and password

      default_user = {{ .Values.auth.username }}

      {{- if and (not .Values.auth.securePassword) .Values.auth.password }}

      default_pass = {{ .Values.auth.password }}

      {{- end }}

      {{- if .Values.clustering.enabled }}

      ## Clustering

      ##

      cluster_name = {{ default (include "common.names.fullname" .)
      .Values.clustering.name }}

      cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s

      cluster_formation.k8s.host = kubernetes.default

      cluster_formation.k8s.address_type = {{ .Values.clustering.addressType }}

      {{- $svcName := printf "%s-%s" (include "common.names.fullname" .)
      (default "headless" .Values.servicenameOverride) }}

      cluster_formation.k8s.service_name = {{ $svcName }}

      cluster_formation.k8s.hostname_suffix = .{{ $svcName }}.{{ include
      "common.names.namespace" . }}.svc.{{ .Values.clusterDomain }}

      cluster_formation.node_cleanup.interval = 10

      cluster_formation.node_cleanup.only_log_warning = true

      cluster_partition_handling = {{ .Values.clustering.partitionHandling }}

      {{- end }}

      {{ if and .Values.clustering.enabled .Values.loadDefinition.enabled }}

      cluster_formation.target_cluster_size_hint = {{ .Values.replicaCount }}

      {{ end }}

      {{- if .Values.loadDefinition.enabled }}

      load_definitions = {{ .Values.loadDefinition.file }}

      {{- end }}

      # queue master locator

      queue_master_locator = {{ .Values.queue_master_locator }}

      # enable loopback user

      {{- if not (empty .Values.auth.username) }}

      loopback_users.{{ .Values.auth.username }} = {{
      .Values.auth.enableLoopbackUser }}

      {{- else}}

      loopback_users.guest = {{ .Values.auth.enableLoopbackUser }}

      {{- end }}

      {{ template "rabbitmq.extraConfiguration" . }}

      {{- if .Values.auth.tls.enabled }}

      ssl_options.verify = {{ .Values.auth.tls.sslOptionsVerify }}

      listeners.ssl.default = {{ .Values.service.ports.amqpTls }}

      ssl_options.fail_if_no_peer_cert = {{ .Values.auth.tls.failIfNoPeerCert }}

      ssl_options.cacertfile = /opt/bitnami/rabbitmq/certs/ca_certificate.pem

      ssl_options.certfile = /opt/bitnami/rabbitmq/certs/server_certificate.pem

      ssl_options.keyfile = /opt/bitnami/rabbitmq/certs/server_key.pem

      {{- if .Values.auth.tls.sslOptionsPassword.enabled }}

      ssl_options.password = {{ template "rabbitmq.tlsSslOptionsPassword" . }}

      {{- end }}

      {{- end }}

      {{- if .Values.ldap.enabled }}

      auth_backends.1.authn = ldap

      auth_backends.1.authz = {{ ternary "ldap" "internal"
      .Values.ldap.authorisationEnabled }}

      auth_backends.2 = internal

      {{- $host :=  list }}

      {{- $port :=  ternary 636 389 .Values.ldap.tls.enabled }}

      {{- if .Values.ldap.uri }}

      {{- $hostPort := get (urlParse .Values.ldap.uri) "host" }}

      {{- $host = list (index (splitList ":" $hostPort) 0) -}}

      {{- if (contains ":" $hostPort) }}

      {{- $port = index (splitList ":" $hostPort) 1 -}}

      {{- end }}

      {{- end }}

      {{- range $index, $server := concat $host .Values.ldap.servers }}

      auth_ldap.servers.{{ add $index 1 }} = {{ $server }}

      {{- end }}

      auth_ldap.port = {{ coalesce .Values.ldap.port $port }}

      {{- if or .Values.ldap.user_dn_pattern .Values.ldap.userDnPattern }}

      auth_ldap.user_dn_pattern = {{ coalesce .Values.ldap.user_dn_pattern
      .Values.ldap.userDnPattern }}

      {{- end }}

      {{- if .Values.ldap.basedn }}

      auth_ldap.dn_lookup_base = {{ .Values.ldap.basedn }}

      {{- end }}

      {{- if .Values.ldap.uidField }}

      auth_ldap.dn_lookup_attribute = {{ .Values.ldap.uidField }}

      {{- end }}

      {{- if .Values.ldap.binddn }}

      auth_ldap.dn_lookup_bind.user_dn = {{ .Values.ldap.binddn }}

      auth_ldap.dn_lookup_bind.password = {{ required "'ldap.bindpw' is required
      when 'ldap.binddn' is defined" .Values.ldap.bindpw }}

      {{- end }}

      {{- if .Values.ldap.tls.enabled }}

      auth_ldap.use_ssl = {{ not .Values.ldap.tls.startTls }}

      auth_ldap.use_starttls = {{ .Values.ldap.tls.startTls }}

      {{- if .Values.ldap.tls.CAFilename }}

      auth_ldap.ssl_options.cacertfile = {{
      .Values.ldap.tls.certificatesMountPath }}/{{ .Values.ldap.tls.CAFilename
      }}

      {{- end }}

      {{- if .Values.ldap.tls.certFilename }}

      auth_ldap.ssl_options.certfile = {{ .Values.ldap.tls.certificatesMountPath
      }}/{{ .Values.ldap.tls.certFilename }}

      auth_ldap.ssl_options.keyfile = {{ .Values.ldap.tls.certificatesMountPath
      }}/{{ required "'ldap.tls.certKeyFilename' is required when
      'ldap.tls.certFilename' is defined" .Values.ldap.tls.certKeyFilename }}

      {{- end }}

      {{- if .Values.ldap.tls.skipVerify }}

      auth_ldap.ssl_options.verify = verify_none

      auth_ldap.ssl_options.fail_if_no_peer_cert = false

      {{- else if .Values.ldap.tls.verify }}

      auth_ldap.ssl_options.verify = {{ .Values.ldap.tls.verify }}

      {{- end }}

      {{- end }}

      {{- end }}

      ## Prometheus metrics

      ##

      prometheus.tcp.port = {{ .Values.containerPorts.metrics }}

      {{- if .Values.memoryHighWatermark.enabled }}

      ## Memory Threshold

      ##

      total_memory_available_override_value = {{ include "rabbitmq.toBytes" (dig
      "limits" "memory" "" .Values.resources) }}

      {{- if (eq .Values.memoryHighWatermark.type "absolute") }}

      vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{
      include "rabbitmq.toBytes" .Values.memoryHighWatermark.value }}

      {{- else if (eq .Values.memoryHighWatermark.type "relative") }}

      vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{
      .Values.memoryHighWatermark.value }}

      {{- end }}

      ## TCP Listen Options

      ##

      tcp_listen_options.backlog = {{ .Values.tcpListenOptions.backlog }}

      tcp_listen_options.nodelay = {{ .Values.tcpListenOptions.nodelay }}

      tcp_listen_options.linger.on      = {{
      .Values.tcpListenOptions.linger.lingerOn }}

      tcp_listen_options.linger.timeout = {{
      .Values.tcpListenOptions.linger.timeout }}

      tcp_listen_options.keepalive = {{ .Values.tcpListenOptions.keepalive }}

      {{- end }}
    configurationExistingSecret: ""
    containerPorts:
      amqp: 5672
      amqpTls: 5671
      dist: 25672
      epmd: 4369
      manager: 15672
      metrics: 9419
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
          - ALL
      enabled: true
      readOnlyRootFilesystem: true
      runAsGroup: 1001
      runAsNonRoot: true
      runAsUser: 1001
      seLinuxOptions: null
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    diagnosticMode:
      args:
        - infinity
      command:
        - sleep
      enabled: false
    dnsConfig: {}
    dnsPolicy: ""
    enableServiceLinks: true
    extraConfiguration: |-
      #default_vhost = {{ .Release.Namespace }}-vhost
      #disk_free_limit.absolute = 50MB
    extraConfigurationExistingSecret: ""
    extraContainerPorts: []
    extraDeploy: []
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraPlugins: rabbitmq_auth_backend_ldap
    extraSecrets: {}
    extraSecretsPrependReleaseName: false
    extraVolumeMounts: []
    extraVolumes: []
    featureFlags: ""
    fullnameOverride: ""
    global:
      compatibility:
        openshift:
          adaptSecurityContext: auto
      defaultStorageClass: ""
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
    hostAliases: []
    image:
      debug: false
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/rabbitmq
      tag: 3.13.7-debian-12-r2
    ingress:
      annotations: {}
      enabled: false
      existingSecret: ""
      extraHosts: []
      extraPaths: []
      extraRules: []
      extraTls: []
      hostname: rabbitmq.local
      ingressClassName: ""
      path: /
      pathType: ImplementationSpecific
      secrets: []
      selfSigned: false
      tls: false
    initContainers: []
    initScripts: {}
    initScriptsCM: ""
    initScriptsSecret: ""
    kubeVersion: ""
    ldap:
      authorisationEnabled: false
      basedn: ""
      binddn: ""
      bindpw: ""
      enabled: false
      port: ""
      servers: []
      tls:
        CAFilename: ""
        certFilename: ""
        certKeyFilename: ""
        certificatesMountPath: /opt/bitnami/rabbitmq/ldap/certs
        certificatesSecret: ""
        enabled: false
        skipVerify: false
        startTls: false
        verify: verify_peer
      uidField: ""
      uri: ""
      userDnPattern: ""
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 120
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 20
    loadDefinition:
      enabled: false
      existingSecret: ""
      file: /app/load_definition.json
    logs: "-"
    maxAvailableSchedulers: ""
    memoryHighWatermark:
      enabled: false
      type: relative
      value: 0.4
    metrics:
      enabled: false
      plugins: rabbitmq_prometheus
      podAnnotations:
        prometheus.io/port: "{{ .Values.service.ports.metrics }}"
        prometheus.io/scrape: "true"
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ""
        rules: []
      serviceMonitor:
        annotations: {}
        default:
          enabled: false
          honorLabels: false
          interval: 30s
          metricRelabelings: []
          relabelings: []
          scrapeTimeout: ""
        detailed:
          enabled: false
          family: []
          honorLabels: false
          interval: 30s
          metricRelabelings: []
          relabelings: []
          scrapeTimeout: ""
          vhost: []
        enabled: false
        honorLabels: false
        interval: 30s
        jobLabel: ""
        labels: {}
        metricRelabelings: []
        namespace: ""
        params: {}
        path: ""
        perObject:
          enabled: false
          honorLabels: false
          interval: 30s
          metricRelabelings: []
          relabelings: []
          scrapeTimeout: ""
        podTargetLabels: {}
        relabelings: []
        scrapeTimeout: ""
        selector: {}
        targetLabels: {}
    nameOverride: ""
    namespaceOverride: ""
    networkPolicy:
      addExternalClientAccess: true
      allowExternal: true
      allowExternalEgress: true
      enabled: true
      extraEgress: []
      extraIngress: []
      ingressNSMatchLabels: {}
      ingressNSPodMatchLabels: {}
      ingressPodMatchLabels: {}
      kubeAPIServerPorts:
        - 443
        - 6443
        - 8443
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    onlineSchedulers: ""
    pdb:
      create: true
      maxUnavailable: ""
      minAvailable: ""
    persistence:
      accessModes:
        - ReadWriteOnce
      annotations: {}
      enabled: true
      existingClaim: ""
      labels: {}
      mountPath: /opt/bitnami/rabbitmq/.rabbitmq/mnesia
      selector: {}
      size: 8Gi
      storageClass: ""
      subPath: ""
    persistentVolumeClaimRetentionPolicy:
      enabled: false
      whenDeleted: Retain
      whenScaled: Retain
    plugins: rabbitmq_management rabbitmq_peer_discovery_k8s
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podManagementPolicy: OrderedReady
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      fsGroupChangePolicy: Always
      supplementalGroups: []
      sysctls: []
    priorityClassName: ""
    queue_master_locator: min-masters
    rbac:
      create: true
      rules: []
    readinessProbe:
      enabled: true
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 20
    replicaCount: 1
    resources: {}
    resourcesPreset: micro
    schedulerName: ""
    service:
      allocateLoadBalancerNodePorts: true
      annotations: {}
      annotationsHeadless: {}
      clusterIP: ""
      distPortEnabled: true
      epmdPortEnabled: true
      externalIPs: []
      externalTrafficPolicy: Cluster
      extraPorts: []
      extraPortsHeadless: []
      headless:
        annotations: {}
      labels: {}
      loadBalancerClass: ""
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      managerPortEnabled: true
      nodePorts:
        amqp: ""
        amqpTls: ""
        dist: ""
        epmd: ""
        manager: ""
        metrics: ""
      portEnabled: true
      portNames:
        amqp: amqp
        amqpTls: amqp-tls
        dist: dist
        epmd: epmd
        manager: http-stats
        metrics: metrics
      ports:
        amqp: 5672
        amqpTls: 5671
        dist: 25672
        epmd: 4369
        manager: 15672
        metrics: 9419
      sessionAffinity: None
      sessionAffinityConfig: {}
      type: ClusterIP
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: false
      create: true
      name: ""
    serviceBindings:
      enabled: false
    servicenameOverride: ""
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 20
    statefulsetAnnotations: {}
    statefulsetLabels: {}
    tcpListenOptions:
      backlog: 128
      keepalive: false
      linger:
        lingerOn: true
        timeout: 0
      nodelay: true
    terminationGracePeriodSeconds: 120
    tolerations: []
    topologySpreadConstraints: []
    ulimitNofiles: "65535"
    updateStrategy:
      type: RollingUpdate
    volumePermissions:
      containerSecurityContext:
        runAsUser: 0
        seLinuxOptions: null
      enabled: false
      image:
        digest: ""
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/os-shell
        tag: 12-debian-12-r28
      resources: {}
      resourcesPreset: nano
